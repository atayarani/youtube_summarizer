# Generated by CodiumAI
import os

# Dependencies:
# pip install pytest-mock
import pytest
from langchain_core.messages import SystemMessage

from src.ai import AI
from src.exceptions import InvalidTranscript


class MockTranscript:
    def __init__(self, content, metadata):
        self.content = content
        self.metadata = metadata


class MockMetadata:
    def __init__(self, title, publish_date, author, url):
        self.title = title
        self.publish_date = publish_date
        self.author = author
        self.url = url


# Generated by CodiumAI

import pytest


class TestTakeaways:
    # Raises a ValueError when messages is None.
    def test_raises_value_error_when_messages_is_none(self, mocker):
        # Create an instance of the AI class
        ai = AI(
            MockTranscript(
                "This is a transcript",
                MockMetadata(
                    title="Test title",
                    publish_date="2021-01-01",
                    author="Test author",
                    url="https://www.youtube.com/watch?v=dQw4w9WgXcQ",
                ),
            )
        )

        # Call the takeaways method with messages set to None
        with pytest.raises(ValueError):
            ai._chat(temperature=0.0, messages=None)

    # Raises a KeyError when the OPENAI_API_KEY environment variable is not set.
    def test_raises_key_error_when_openai_api_key_not_set(self, mocker):
        # Create a mock Transcript object
        class MockTranscript:
            def __init__(self, content, metadata):
                self.content = content
                self.metadata = metadata

        key = os.environ.pop("OPENAI_API_KEY", None)
        # Create an instance of the AI class without setting OPENAI_API_KEY environment variable
        with pytest.raises(KeyError):
            ai = AI(
                MockTranscript(
                    "This is a transcript",
                    MockMetadata(
                        title="Test title",
                        publish_date="2021-01-01",
                        author="Test author",
                        url="https://www.youtube.com/watch?v=dQw4w9WgXcQ",
                    ),
                )
            )

        os.environ["OPENAI_API_KEY"] = key

    # Handles edge cases when the transcript is too long.
    def test_handles_edge_cases_when_transcript_is_too_long(self, mocker):
        # Mock the ChatOpenAI class
        class MockChatOpenAI:
            def __init__(self, temperature, model):
                pass

            def stream(self, messages):
                return [
                    SystemMessage(content="Key takeaway 1"),
                    SystemMessage(content="Key takeaway 2"),
                ]

        mocker.patch("src.ai.ChatOpenAI", MockChatOpenAI)

        # Create an instance of the AI class
        ai = AI(
            MockTranscript(
                "This is a transcript",
                MockMetadata(
                    title="Test title",
                    publish_date="2021-01-01",
                    author="Test author",
                    url="https://www.youtube.com/watch?v=dQw4w9WgXcQ",
                ),
            )
        )

        # Call the takeaways method
        result = ai.takeaways()

        # Assert that the result is a list
        assert isinstance(result, list)

        # Assert that the result contains the expected key takeaways
        assert result == ["Key takeaway 1Key takeaway 2"]


class Test_SplitTranscript:
    # Returns a list of transcript chunks when given a valid transcript.
    def test_valid_transcript(self):
        transcript = "This is a valid transcript."
        ai = AI(MockTranscript(transcript, None))
        chunks = ai._split_transcript()
        assert isinstance(chunks, list)
        assert len(chunks) > 0

    # Returns a list with a single chunk when given a transcript shorter than the chunk size.
    def test_short_transcript(self):
        transcript = "Short transcript."
        ai = AI(MockTranscript(transcript, None))
        chunks = ai._split_transcript()
        assert isinstance(chunks, list)
        assert len(chunks) == 1

    # Raises a TypeError when given a transcript that is not a string.
    def test_non_string_transcript(self):
        transcript = 12345
        with pytest.raises(TypeError):
            ai = AI(MockTranscript(transcript, None))
            ai._split_transcript()


class TestSummary:
    # Generates a summary of the transcript when provided with a valid transcript and metadata.
    def test_valid_transcript_and_metadata(self, mocker):
        # Mock the necessary dependencies
        transcript = MockTranscript(
            "This is a transcript",
            MockMetadata(
                title="Test title",
                publish_date="2021-01-01",
                author="Test author",
                url="https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            ),
        )
        mocker.patch.object(AI, "_split_transcript", return_value=["This is a chunk"])
        mocker.patch.object(AI, "_chat", return_value=["Generated summary"])

        # Initialize the AI object
        ai = AI(transcript)

        # Call the summary method
        result = ai.summary()

        # Assert the result
        assert result == ["Generated summary"]

    # Returns a list of strings representing the generated summary.
    def test_return_type(self, mocker):
        # Mock the necessary dependencies
        transcript = MockTranscript(
            "This is a transcript",
            MockMetadata(
                title="Test title",
                publish_date="2021-01-01",
                author="Test author",
                url="https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            ),
        )
        mocker.patch.object(AI, "_split_transcript", return_value=["This is a chunk"])
        mocker.patch.object(AI, "_chat", return_value=["Generated summary"])

        # Initialize the AI object
        ai = AI(transcript)

        # Call the summary method
        result = ai.summary()

        # Assert the return type
        assert isinstance(result, list)

    # Uses a character-based text splitter to split the transcript into chunks.
    def test_text_splitter(self, mocker):
        # Mock the necessary dependencies
        transcript = MockTranscript(
            "This is a transcript",
            MockMetadata(
                title="Test title",
                publish_date="2021-01-01",
                author="Test author",
                url="https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            ),
        )
        mocker.patch.object(AI, "_split_transcript", return_value=["This is a chunk"])
        mocker.patch.object(AI, "_chat", return_value=["Generated summary"])

        # Initialize the AI object
        ai = AI(transcript)

        # Call the summary method
        ai.summary()

        # Assert that the text splitter is called
        AI._split_transcript.assert_called_once()
